'use client';

import { useMemo, useState, useRef, useCallback } from 'react';
import { Settings, Trash2, ZoomOut, MoreVertical, SplitSquareHorizontal, SplitSquareVertical, Pencil, Plus } from 'lucide-react';
import uPlot from 'uplot';
import { UPlotChart, UPlotSeries, UPlotAxis } from '@/components/UPlotChart';
import { TelemetryFrame } from '@/types/telemetry';
import { PlotConfig, CHANNEL_METADATA, TelemetryChannel } from '@/types/plotConfig';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { PlotConfigDialog } from '@/components/PlotConfigDialog';

interface ConfigurableTelemetryChartProps {
  data: TelemetryFrame[];
  compareData?: TelemetryFrame[];
  config: PlotConfig;
  onConfigChange: (config: PlotConfig) => void;
  onDelete?: () => void;
  onSplitHorizontal?: () => void;
  onSplitVertical?: () => void;
  onAddRowBelow?: () => void;
  height?: number;
  syncedHoverValue?: number | null;
  onHoverChange?: (value: number | null) => void;
}

export function ConfigurableTelemetryChart({
  data,
  compareData,
  config,
  onConfigChange,
  onDelete,
  onSplitHorizontal,
  onSplitVertical,
  onAddRowBelow,
  height = 250,
  syncedHoverValue,
  onHoverChange,
}: ConfigurableTelemetryChartProps) {
  const [showConfigDialog, setShowConfigDialog] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Zoom state
  const [zoomDomain, setZoomDomain] = useState<{ x?: [number, number]; y?: [number, number]; y2?: [number, number] } | null>(null);
  
  // Hover state
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  const [syncedHoverIndex, setSyncedHoverIndex] = useState<number | null>(null);

  // Use synced hover value if provided
  const effectiveHoverIndex = syncedHoverValue !== undefined && syncedHoverValue !== null ? syncedHoverIndex : hoveredIndex;

  // Transform telemetry data based on configuration
  const chartData = useMemo(() => {
    if (!data || data.length === 0) return [];

    // Helper to get channel value from frame
    const getChannelValue = (frame: TelemetryFrame, channel: TelemetryChannel): number => {
      switch (channel) {
        case 'time':
          return frame.lapTime / 1000; // Convert to seconds
        case 'normalizedPosition':
          return frame.normalizedPosition * 100; // Convert to percentage
        case 'throttle':
          return frame.throttle * 100;
        case 'brake':
          return frame.brake * 100;
        case 'steering':
          return Math.abs(frame.steering) * 100; // Convert to 0-100 range
        case 'speed':
          return frame.speed;
        case 'gear':
          return frame.gear;
        case 'rpm':
          return frame.rpm;
        default:
          return 0;
      }
    };

    // Build chart data points
    return data.map((frame, index) => {
      const point: any = { index };

      // Set primary X-axis value
      point.xAxis = getChannelValue(frame, config.xAxis);

      // Add configured channels
      config.channels.forEach((channelConfig) => {
        const yValue = getChannelValue(frame, channelConfig.channel);
        point[channelConfig.id] = yValue;

        // Add compare data if available
        if (compareData && compareData[index]) {
          const compareYValue = getChannelValue(compareData[index], channelConfig.channel);
          point[`compare_${channelConfig.id}`] = compareYValue;
        }
      });

      return point;
    });
  }, [data, compareData, config]);

  // Find the data point closest to the synced hover value
  const syncedHoveredData = useMemo(() => {
    if (effectiveHoverValue === null || chartData.length === 0) return null;
    
    // Find the closest data point based on x-axis value
    let closest = null;
    let minDiff = Infinity;
    
    for (const point of chartData) {
      const diff = Math.abs(point.xAxis - effectiveHoverValue);
      if (diff < minDiff) {
        minDiff = diff;
        closest = point;
      }
    }
    
    return closest;
  }, [effectiveHoverValue, chartData]);

  // Get domain for primary Y axis based on channel types
  const getPrimaryYAxisDomain = (): [number, number] | ['auto', 'auto'] => {
    const primaryChannels = config.channels.filter(ch => ch.useSecondaryAxis !== true);
    if (primaryChannels.length === 0) return ['auto', 'auto'];
    
    // Check if all primary channels are percentage-based
    const allPercentage = primaryChannels.every((ch) => {
      const metadata = CHANNEL_METADATA[ch.channel];
      return metadata.unit === '%';
    });

    if (allPercentage) {
      return [0, 100];
    }

    return ['auto', 'auto'];
  };

  // Get domain for secondary Y axis
  const getSecondaryYAxisDomain = (): [number, number] | ['auto', 'auto'] => {
    const secondaryChannels = config.channels.filter(ch => ch.useSecondaryAxis === true);
    if (secondaryChannels.length === 0) return ['auto', 'auto'];
    
    // Check if all secondary channels are percentage-based
    const allPercentage = secondaryChannels.every((ch) => {
      const metadata = CHANNEL_METADATA[ch.channel];
      return metadata.unit === '%';
    });

    if (allPercentage) {
      return [0, 100];
    }

    return ['auto', 'auto'];
  };

  // Check if any channel uses secondary axis
  const hasSecondaryAxis = config.channels.some(ch => ch.useSecondaryAxis === true);

  // Zoom handlers
  const handleMouseDown = (e: any) => {
    // Prevent text selection during drag
    if (e?.nativeEvent) {
      e.nativeEvent.preventDefault();
    }
    if (e && e.activeLabel !== undefined) {
      setRefAreaLeft(e.activeLabel);
    }
  };

  const handleMouseMove = (e: any) => {
    // Notify parent of hover position for syncing across charts
    if (e && e.activeLabel !== undefined && onHoverChange) {
      onHoverChange(e.activeLabel);
    }
    
    // Update hover data for legend
    if (e && e.activePayload) {
      setHoveredData(e.activePayload[0]?.payload);
    }
    
    // Handle zoom selection
    if (refAreaLeft && e && e.activeLabel !== undefined) {
      setRefAreaRight(e.activeLabel);
      // Prevent text selection during drag
      if (e?.nativeEvent) {
        e.nativeEvent.preventDefault();
      }
    }
  };
  
  const handleMouseLeave = () => {
    setHoveredData(null);
    if (onHoverChange) {
      onHoverChange(null);
    }
  };

  const handleMouseUp = () => {
    if (refAreaLeft && refAreaRight && refAreaLeft !== refAreaRight) {
      // Zoom in
      const left = Math.min(Number(refAreaLeft), Number(refAreaRight));
      const right = Math.max(Number(refAreaLeft), Number(refAreaRight));
      
      // Get Y-axis ranges for the zoomed region
      const zoomedData = chartData.filter(
        (item) => item.xAxis >= left && item.xAxis <= right
      );
      
      let yLeftMin = Infinity;
      let yLeftMax = -Infinity;
      let yRightMin = Infinity;
      let yRightMax = -Infinity;
      
      zoomedData.forEach((item) => {
        config.channels.forEach((ch) => {
          const value = item[ch.id];
          if (value !== undefined && value !== null) {
            if (ch.useSecondaryAxis === true) {
              yRightMin = Math.min(yRightMin, value);
              yRightMax = Math.max(yRightMax, value);
            } else {
              yLeftMin = Math.min(yLeftMin, value);
              yLeftMax = Math.max(yLeftMax, value);
            }
          }
        });
      });
      
      // Add 5% padding to Y-axis ranges
      const yLeftPadding = (yLeftMax - yLeftMin) * 0.05;
      const yRightPadding = (yRightMax - yRightMin) * 0.05;
      
      setZoomDomain({
        x: [left, right],
        yLeft: yLeftMin !== Infinity ? [yLeftMin - yLeftPadding, yLeftMax + yLeftPadding] : undefined,
        yRight: yRightMin !== Infinity ? [yRightMin - yRightPadding, yRightMax + yRightPadding] : undefined,
      });
    }
    
    setRefAreaLeft('');
    setRefAreaRight('');
  };

  const handleZoomOut = () => {
    setZoomDomain(null);
    setRefAreaLeft('');
    setRefAreaRight('');
  };

  // Custom legend component that shows current values on hover
  const renderCustomLegend = () => {
    // Use synced data if available, otherwise use local hover data
    const displayData = syncedHoveredData || hoveredData;
    
    // Get X-axis metadata
    const xAxisMeta = CHANNEL_METADATA[config.xAxis];
    const xAxisValue = displayData?.xAxis;
    
    return (
      <div className="flex flex-wrap gap-4 justify-center mt-4 px-2">
        {/* X-Axis value - only show when hovering */}
        {displayData && xAxisValue !== undefined && (
          <div className="flex items-center gap-2 pr-4 border-r border-gray-300">
            <span className="text-sm">
              {xAxisMeta.label}:{' '}
              <span className="font-semibold">
                {xAxisValue.toFixed(1)}{xAxisMeta.unit ? ` ${xAxisMeta.unit}` : ''}
              </span>
            </span>
          </div>
        )}
        
        {config.channels.map((channelConfig) => {
          const channelLabel = CHANNEL_METADATA[channelConfig.channel].label;
          const channelUnit = CHANNEL_METADATA[channelConfig.channel].unit;
          const value = displayData?.[channelConfig.id];
          const compareValue = displayData?.[`compare_${channelConfig.id}`];
          const hasCompareData = compareData && compareData.length > 0;
          
          return (
            <div key={channelConfig.id} className="flex items-center gap-2">
              <div
                className="w-3 h-3 rounded-sm"
                style={{ backgroundColor: channelConfig.color || '#000000' }}
              />
              <span className="text-sm">
                {channelLabel}:{' '}
                <span className="font-semibold">
                  {value !== undefined && value !== null
                    ? `${value.toFixed(1)}${channelUnit ? ` ${channelUnit}` : ''}`
                    : '—'}
                </span>
                {hasCompareData && compareValue !== undefined && compareValue !== null && (
                  <span className="text-muted-foreground ml-1">
                    (vs {compareValue.toFixed(1)}{channelUnit ? ` ${channelUnit}` : ''})
                  </span>
                )}
              </span>
            </div>
          );
        })}
      </div>
    );
  };

  // Calculate total container height: padding (16px top + 16px bottom) + header (~44px with mb-4) + chart height
  const PADDING_VERTICAL = 32; // p-4 = 16px top + 16px bottom
  const HEADER_HEIGHT = 44; // Approximate height of title + buttons + mb-4
  const totalHeight = PADDING_VERTICAL + HEADER_HEIGHT + height;

  return (
    <TooltipProvider>
      <div 
        className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow select-none flex flex-col"
        style={{ height: `${totalHeight}px` }}
      >
        <div className="flex items-center justify-between mb-4 flex-shrink-0">
          <h3 className="text-lg font-semibold">{config.title}</h3>
          <div className="flex gap-2">
            {zoomDomain && (
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={handleZoomOut}
                  >
                    <ZoomOut className="h-4 w-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Reset Zoom</p>
                </TooltipContent>
              </Tooltip>
            )}
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => setShowConfigDialog(true)}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Edit Plot</p>
              </TooltipContent>
            </Tooltip>
            {onDelete && (
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={onDelete}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Delete Plot</p>
                </TooltipContent>
              </Tooltip>
            )}
            {(onSplitHorizontal || onSplitVertical || onAddRowBelow) && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="icon">
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  {onSplitHorizontal && (
                    <DropdownMenuItem onClick={onSplitHorizontal}>
                      <SplitSquareHorizontal className="h-4 w-4 mr-2" />
                      Split Horizontally
                    </DropdownMenuItem>
                  )}
                  {onSplitVertical && (
                    <DropdownMenuItem onClick={onSplitVertical}>
                      <SplitSquareVertical className="h-4 w-4 mr-2" />
                      Split Vertically
                    </DropdownMenuItem>
                  )}
                  {onAddRowBelow && (
                    <DropdownMenuItem onClick={onAddRowBelow}>
                      <Plus className="h-4 w-4 mr-2" />
                      Add Row Below
                    </DropdownMenuItem>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>

      {config.channels.length === 0 ? (
        <div className="flex items-center justify-center text-muted-foreground" style={{ height: `${height}px` }}>
          <div className="text-center">
            <p className="mb-2">No channels configured</p>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowConfigDialog(true)}
            >
              Configure Plot
            </Button>
          </div>
        </div>
      ) : (
        <ResponsiveContainer width="100%" height={height} style={{ userSelect: 'none' }}>
          <LineChart 
            data={chartData}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            style={{ userSelect: 'none' } as any}
          >
            <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
            
            <XAxis
              dataKey="xAxis"
              type="number"
              label={{
                value: config.xAxisLabel,
                position: 'insideBottom',
                offset: -5,
              }}
              tick={{ fontSize: 11 }}
              domain={zoomDomain?.x || ['auto', 'auto']}
              allowDataOverflow
            />
            
            {/* Primary Y-Axis (Left) */}
            <YAxis
              yAxisId="left"
              label={{
                value: config.yAxisLabel,
                angle: -90,
                position: 'insideLeft',
                offset: 0,
                style: { textAnchor: 'middle' },
              }}
              domain={zoomDomain?.yLeft || getPrimaryYAxisDomain()}
              allowDataOverflow
              type="number"
            />
            
            {/* Secondary Y-Axis (Right) - only if needed */}
            {hasSecondaryAxis && (
              <YAxis
                yAxisId="right"
                orientation="right"
                label={{
                  value: config.yAxisLabelSecondary || 'Secondary',
                  angle: 90,
                  position: 'insideRight',
                  offset: 0,
                  style: { textAnchor: 'middle' },
                }}
                domain={zoomDomain?.yRight || getSecondaryYAxisDomain()}
                allowDataOverflow
                type="number"
              />
            )}

            {/* Render lines for each configured channel */}
            {config.channels.map((channelConfig) => {
              const channelLabel = CHANNEL_METADATA[channelConfig.channel].label;
              const yAxis = channelConfig.useSecondaryAxis === true ? 'right' : 'left';
              return (
                <Line
                  key={channelConfig.id}
                  yAxisId={yAxis}
                  type="monotone"
                  dataKey={channelConfig.id}
                  stroke={channelConfig.color || '#000000'}
                  strokeWidth={2}
                  dot={(props: any) => {
                    const displayData = syncedHoveredData || hoveredData;
                    if (displayData && props.payload.xAxis === displayData.xAxis) {
                      return (
                        <circle
                          key={`dot-${channelConfig.id}-${props.index}`}
                          cx={props.cx}
                          cy={props.cy}
                          r={4}
                          fill={channelConfig.color || '#000000'}
                          stroke="#fff"
                          strokeWidth={2}
                        />
                      );
                    }
                    return <g key={`dot-${channelConfig.id}-${props.index}`} />;
                  }}
                  name={channelLabel}
                  isAnimationActive={false}
                />
              );
            })}

            {/* Render compare lines if available */}
            {compareData &&
              config.channels.map((channelConfig) => {
                const channelLabel = CHANNEL_METADATA[channelConfig.channel].label;
                const yAxis = channelConfig.useSecondaryAxis === true ? 'right' : 'left';
                return (
                  <Line
                    key={`compare_${channelConfig.id}`}
                    yAxisId={yAxis}
                    type="monotone"
                    dataKey={`compare_${channelConfig.id}`}
                    stroke={channelConfig.color || '#000000'}
                    strokeWidth={2}
                    strokeDasharray="5 5"
                    dot={(props: any) => {
                      const displayData = syncedHoveredData || hoveredData;
                      if (displayData && props.payload.xAxis === displayData.xAxis) {
                        return (
                          <circle
                            key={`compare-dot-${channelConfig.id}-${props.index}`}
                            cx={props.cx}
                            cy={props.cy}
                            r={3.5}
                            fill={channelConfig.color || '#000000'}
                            stroke="#fff"
                            strokeWidth={2}
                            opacity={0.8}
                          />
                        );
                      }
                      return <g key={`compare-dot-${channelConfig.id}-${props.index}`} />;
                    }}
                    name={`Compare ${channelLabel}`}
                    opacity={0.6}
                    isAnimationActive={false}
                  />
                );
              })}
            
            {/* Zoom selection area */}
            {refAreaLeft && refAreaRight && (
              <ReferenceArea
                yAxisId="left"
                x1={refAreaLeft}
                x2={refAreaRight}
                strokeOpacity={0.3}
                fill="#8884d8"
                fillOpacity={0.3}
              />
            )}
          </LineChart>
        </ResponsiveContainer>
      )}
      
      {/* Custom hover line overlay - rendered outside Recharts to avoid state issues */}
      {config.channels.length > 0 && effectiveHoverValue !== null && (
        <div 
          style={{
            position: 'relative',
            marginTop: `-${height}px`,
            height: `${height}px`,
            pointerEvents: 'none',
            overflow: 'hidden'
          }}
        >
          <svg width="100%" height={height} style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Calculate the x position based on the data range */}
            {(() => {
              if (chartData.length === 0) return null;
              const xValues = chartData.map(d => d.xAxis).filter(x => typeof x === 'number' && !isNaN(x));
              if (xValues.length === 0) return null;
              
              const xMin = Math.min(...xValues);
              const xMax = Math.max(...xValues);
              const xRange = xMax - xMin;
              if (xRange === 0 || !isFinite(xRange)) return null;
              
              // Calculate position as percentage (accounting for margins)
              const margin = 5; // matches chart margin
              const chartWidth = 100; // percentage
              const xPercent = ((effectiveHoverValue - xMin) / xRange) * (chartWidth - 2 * margin) + margin;
              
              // Validate the calculated percentage
              if (!isFinite(xPercent) || xPercent < 0 || xPercent > 100) return null;
              
              return (
                <line
                  x1={`${xPercent}%`}
                  y1="0"
                  x2={`${xPercent}%`}
                  y2={height}
                  stroke="#888"
                  strokeWidth="1"
                  strokeDasharray="3 3"
                  opacity="0.7"
                />
              );
            })()}
          </svg>
        </div>
      )}
      
      {/* Custom legend with values */}
      {config.channels.length > 0 && renderCustomLegend()}

      <PlotConfigDialog
        open={showConfigDialog}
        onOpenChange={setShowConfigDialog}
        config={config}
        onSave={onConfigChange}
      />
      </div>
    </TooltipProvider>
  );
}
